# 需要复习的知识点：
1、位运算实现乘法和除法
2、判断是否平衡二叉树


# 知识点：
判断是否搜索二叉树：
方法一：看中序遍历是否升序
方法二：递归判断

# 算法刷题班笔记：
https://mubu.com/doc/IodJW7cCNk



# 经典题
1.数组中，某个数只出现过一次，其他数出现过2次，找出这个出现一次的数。
- 方法一：哈希表
- 方法二：异或（最优解）

扩展练习：力扣137. 只出现一次的数字 II、260. 只出现一次的数字 III。

2、把一个int型数字a的二进制最右侧1提出，说明：假设a的二进制为0110011100110000，提取后为0000000000010000

答：a&(-a) = a&(~a+1)

3、用双链表实现队列、用单链表实现栈、数组实现栈、数组实现队列

4、设计一个栈，在基本功能的基础上，在实现返回栈中最小元素的功能

要求：pop、push、getMin--获取栈中最小值  的时间复杂度都是O(1)

答：额外加一个最小值栈。

5、用栈实现队列、用队列实现栈

6、递归是否一定能改写成非递归？

答：是

7、Master公式（用于求子递归规模一致的递归算法时间复杂度）

适用场景：T(N) = a*T(n/b)+O(N^d)
- 1)logb(a) < d 时，O(N^d)
- 2)logb(a) >d 时，O(N^logb(a))
- 3)lobb(a) = d 时，O(N^d * logN)

8、归并排序的经典应用
- 1）小和问题：求数组中每个数左边小于自己的数，求这些数的和。要求时间复杂度O(nlogn)

思路：归并过程中收集满足条件的数的和
- 2）求数组中每个数右边满足以下条件的数的个数之和：乘以2之后仍然比当前数小  。要求时间复杂度O(nlogn)
- 3）leetCode 315. 计算右侧小于当前元素的个数（返回数组）
- 4）数逆序对
- 5）求数组中累加和在范围[a,b]上的子数组。要求时间复杂度O(nlogn)

思路：假设0-i整体累加和是X，需要满足的范围是[low,high]。那么，“求必须以i位置结尾的子数组，目标有多少个在[low,up]范围上”，
等同于求“i之前的所有前缀和中，有多少个前缀和在[x-high,x-low]上”。

备注：在前缀和数组的基础上做归并排序