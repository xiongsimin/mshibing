# 需要复习的知识点：
1、位运算实现乘法和除法
2、判断是否平衡二叉树


# 知识点：
判断是否搜索二叉树：
方法一：看中序遍历是否升序
方法二：递归判断

# 算法刷题班笔记：
https://mubu.com/doc/IodJW7cCNk



# 经典题
1.数组中，某个数只出现过一次，其他数出现过2次，找出这个出现一次的数。
- 方法一：哈希表
- 方法二：异或（最优解）

扩展练习：力扣137. 只出现一次的数字 II、260. 只出现一次的数字 III。

2、把一个int型数字a的二进制最右侧1提出，说明：假设a的二进制为0110011100110000，提取后为0000000000010000

答：a&(-a) = a&(~a+1)

3、用双链表实现队列、用单链表实现栈、数组实现栈、数组实现队列

4、设计一个栈，在基本功能的基础上，在实现返回栈中最小元素的功能

要求：pop、push、getMin--获取栈中最小值  的时间复杂度都是O(1)

答：额外加一个最小值栈。

5、用栈实现队列、用队列实现栈

6、递归是否一定能改写成非递归？

答：是

7、Master公式（用于求子递归规模一致的递归算法时间复杂度）

适用场景：T(N) = a*T(n/b)+O(N^d)
- 1)logb(a) < d 时，O(N^d)
- 2)logb(a) >d 时，O(N^logb(a))
- 3)lobb(a) = d 时，O(N^d * logN)

8、归并排序的经典应用
- 1）小和问题：求数组中每个数左边小于自己的数，求这些数的和。要求时间复杂度O(nlogn)

思路：归并过程中收集满足条件的数的和
- 2）求数组中每个数右边满足以下条件的数的个数之和：乘以2之后仍然比当前数小  。要求时间复杂度O(nlogn)
- 3）leetCode 315. 计算右侧小于当前元素的个数（返回数组）要求时间复杂度O(nlogn)
- 4）数逆序对。要求时间复杂度O(nlogn)
- 5）leetCode 327题。求数组中累加和在范围[a,b]上的子数组。要求时间复杂度O(nlogn)

方法一：

思路：假设0-i整体累加和是X，需要满足的范围是[low,high]。那么，“求必须以i位置结尾的子数组，目标有多少个在[low,up]范围上”，
等同于求“i之前的所有前缀和中，有多少个前缀和在[x-high,x-low]上”。

方法二：

有序表（以后学到了再补充）


备注：在前缀和数组的基础上做归并排序

课后练习：归并迭代写法（关键点：步长 1、2、4、8、16...）

9、快速排序
- 1）1.0 版本  复杂度O(N^2)：一次解决一个数，以最右侧数X为基准，X左边<=X，X右边>X。 递归X左侧和X右侧。
- 2）2.0 版本（荷兰国旗问题） 复杂度O(N^2)：一次解决若干个数，以最右侧数X为基准，X左边<X，中间若干数=X，X右边>X。 递归中间X区间的左侧和右侧。
- 3）3.0 版本（随机快排）复杂度O(N*logN)：partition之前，将数组随机一个位置的数放在最右边作为基准值，之后的逻辑同2.0或1.0

解释：3.0版本为什么时间复杂度O(N*logN)？因为最坏情况和最好情况以及中间情况是随机的，根据数学证明（可不关注证明过程），复杂度收敛期望是O(N*logN)

课后练习：快排递归写法和迭代写法（用栈模拟递归）！

