# 需要复习的知识点：
1、位运算实现乘法和除法
2、判断是否平衡二叉树


# 知识点：
## 判断是否搜索二叉树：
方法一：看中序遍历是否升序
方法二：递归判断
## 常见二叉树英文缩写：
AVL：平衡二叉搜索树
BST：二叉搜索树
BT：平衡二叉树

## 有序表TreeMap：
重复key进行put操作，值不会进行覆盖

## 数组结构常用来作为堆结构的底层实际实现
对于数组i位置的元素，在逻辑堆结构中：
i==0时，为根节点
左孩子节点位置：2*i+1
右孩子节点位置：2*i+2
父节点位置：(i-1)/2  向下取整

## 评测网站代码运行时间经验：
C/C++：指令条数（可以简单理解：O(1)代表一条指令）在10^8~10^9范围时，运行时间在1~2秒
Java等有虚拟机的语言：指令条数在10^8~10^9范围时，运行时间在2~

举例：若数量级N=10^6，那么设计算法时，O(N^2)肯定过不了。需要考虑设计一个O(N*logN)甚至O(N)级别的算法

## 笔试前准备经验
先准备好一些对数器模板：
随机生成数组，随机生成链表，随机生成二叉树等。用于获取反例从而更好地调bug。

# 算法刷题班笔记：
https://mubu.com/doc/IodJW7cCNk



# 经典题
1.数组中，某个数只出现过一次，其他数出现过2次，找出这个出现一次的数。
- 方法一：哈希表
- 方法二：异或（最优解）

扩展练习：力扣137. 只出现一次的数字 II、260. 只出现一次的数字 III。

2、把一个int型数字a的二进制最右侧1提出，说明：假设a的二进制为0110011100110000，提取后为0000000000010000

答：a&(-a) = a&(~a+1)

3、用双链表实现队列、用单链表实现栈、数组实现栈、数组实现队列

4、设计一个栈，在基本功能的基础上，在实现返回栈中最小元素的功能

要求：pop、push、getMin--获取栈中最小值  的时间复杂度都是O(1)

答：额外加一个最小值栈。

5、用栈实现队列、用队列实现栈

6、递归是否一定能改写成非递归？

答：是

7、Master公式（用于求子递归规模一致的递归算法时间复杂度）

适用场景：T(N) = a*T(n/b)+O(N^d)
- 1)logb(a) < d 时，O(N^d)
- 2)logb(a) >d 时，O(N^logb(a))
- 3)lobb(a) = d 时，O(N^d * logN)

8、归并排序的经典应用
- 1）小和问题：求数组中每个数左边小于自己的数，求这些数的和。要求时间复杂度O(nlogn)

思路：归并过程中收集满足条件的数的和
- 2）求数组中每个数右边满足以下条件的数的个数之和：乘以2之后仍然比当前数小  。要求时间复杂度O(nlogn)
- 3）leetCode 315. 计算右侧小于当前元素的个数（返回数组）要求时间复杂度O(nlogn)
- 4）数逆序对。要求时间复杂度O(nlogn)
- 5）leetCode 327题。求数组中累加和在范围[a,b]上的子数组。要求时间复杂度O(nlogn)

方法一：

思路：假设0-i整体累加和是X，需要满足的范围是[low,high]。那么，“求必须以i位置结尾的子数组，目标有多少个在[low,up]范围上”，
等同于求“i之前的所有前缀和中，有多少个前缀和在[x-high,x-low]上”。

方法二：

有序表方式解此题（以后学到了再补充）


备注：在前缀和数组的基础上做归并排序

课后练习：归并迭代写法（关键点：步长 1、2、4、8、16...）

9、快速排序
- 1）1.0 版本  复杂度O(N^2)：一次解决一个数，以最右侧数X为基准，X左边<=X，X右边>X。 递归X左侧和X右侧。
- 2）2.0 版本（荷兰国旗问题） 复杂度O(N^2)：一次解决若干个数，以最右侧数X为基准，X左边<X，中间若干数=X，X右边>X。 递归中间X区间的左侧和右侧。
- 3）3.0 版本（随机快排）复杂度O(N*logN)：partition之前，将数组随机一个位置的数放在最右边作为基准值，之后的逻辑同2.0或1.0

解释：3.0版本为什么时间复杂度O(N*logN)？因为最坏情况和最好情况以及中间情况是随机的，根据数学证明（可不关注证明过程），复杂度收敛期望是O(N*logN)

课后练习：快排递归写法和迭代写法（用栈模拟递归）！

10、堆排序经典题目

1）练习堆结构的增删过程

大根堆思路：
- 新增节点（heapinsert）：新加的节点【i位置】一直与父节点【(i-1)/2）】比较，比父节点大则与父节点交换，直到不大于父节点或已来到根节点【0位置】
- 删除根顶节点（heapify）：第一步 根顶节点与根的最后一个叶子节点交换，heapSize--，第二步 从根顶王下探，找左右孩子比自己大的数，交换，并一直往下探，直到左右孩子都比自己小

2）练习手写堆排序

3）优化堆排序中的建队过程

思路：从后往前建堆，建堆时间复杂度能从O(N*logN)优化到O(N)，但整体排序复杂度还是O(N*logN)，无法再优化

4）题目：有一个无序数组，要求进行升序排序。给定的该无序数组有一个规律：排序过程中互换位置的元素距离不超过k。
要求设计一个排序算法void sort(int[] arr,int k).时间复杂度O(N*logk)

5）题目：最大线段重合问题。一组线段，给定起点和终点，一条垂直线扫过，求最大相交次数。int maxCut(int[N][2] lines)。

方法一：暴力方法，用于做对数器的对照组。从min+0.5开始循环，每次加1，加到max-0.5，从而得出最大相交次数

方法二：借助辅助堆。先对所有线段按起点升序排列，再依次考察，堆中小于当前考察线段起始位置的元素弹出，当前线段右边界入堆，得到以当前线段为最大起点的所有线段相交次数。
最终得到最大相交次数。

6）手写加强堆，除了普通堆中的功能。增加：删除任意堆中元素的方法。增加：重新调整某个元素，使堆有效。（修改了某个元素索引值的场景下使用）


11、前缀树

1）前缀树节点结构
```java
// 字符串仅包含26个小写英文情况
public class Node{
	// 经过次数
	int pass;
	// 以此节点为结束次数
	int end;
	// 下个节点list
	List<Node> nexts;
}
```

```java
// 字符串仅包含任意字符的情况
public class Node{
	// 经过次数
	int pass;
	// 以此节点为结束次数
	int end;
	// 下个节点list
	HashMap<Integer,Node> nexts;
}
```

2）前缀树代码实现，课下进行练习，下面仅列出方法签名
```java
public class Trie{
	private Node node;
	
	public Trie(){
		// ...
	}
	
	// 前缀树中加入一个新字符串
	public void insert(String word){
		// ...
	}
	
	// 查询word在前缀树中出现了几次
	public int search(String word){
		// ... 
	}
	
	// 所有加入的字符串中，有几个是以pre这个字符串作为前缀的
	public int prefixNumer(String pre){
		// ...
	}
	
	// 删除
	public void delete(String word){
		// ...
	}
	
}
```

3）理解概念：
按特征分类，排序可分为两种：
 - 基于比较的排序：冒泡、插入、选择、归并、快排、堆排序、希尔排序
 - 不基于比较的排序（以桶排序为代表）：计数排序、基数排序
 
桶排序：是一种排序思想，适用范围有限，仅限于数据样本有限的场景。

基于比较的排序的时间复杂度极限是O(N*logN)，希尔排序时间复杂度为O(N^1.3)~O(N^2)之间，O(N^1.3)比O(N*logN)要差。
不基于比较的排序时间复杂度极限是O(N)，当数组中最大值max大到需要考虑进去时，复杂度为O(N*log10(max))

4）练习基数排序编码


12、排序稳定性：同样的数在排序后不改变相对次序
可以做到稳定性的排序是：冒泡排序、插入排序、归并排序
不能做到稳定性的排序是：选择排序、快速排序、堆排序


13、排序算法总结

1） 排序算法			时间复杂度			额外空间复杂度			稳定性
	
	选择排序			O(N^2)				O(1)					无
	冒泡排序			O(N^2)				O(1)					有
	插入排序			O(N^2)				O(1)					有
	归并排序			O(N*logN)			O(N)					有
	随机快排			O(N*logN)			O(logN)					无
	堆排序				O(N*logN)			O(1)					无
	=========================================================================
	计数排序			O(N)				O(M)					有
	基数排序			O(N)				O(N)					有
	
2)重要的结论：
- 不基于比较的排序，对样本数据有严格要求，不易改写
- 基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用
- 基于比较的排序，时间复杂度极限是O(N*logN)
- 时间复杂度O(N*logN)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存在的
- 为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并

3）常见坑：
- “归并排序 内部缓存法”，可以让归并排序的额外空间复杂度变成O(1)，但是将变得不再稳定
- “原地归并排序”是垃圾贴，会让时间复杂度变成O(N^2)
- “01 stable sort”，快速排序稳定性改进，但会对样本数据要求更多

4）链表相关的课下练习：
- 输入链表头结点，奇数长度返回中点，偶数长度返回上中点
- 输入链表头结点，奇数长度返回中点，偶数长度返回下中点
- 输入链表头结点，奇数长度返回中点前一个，偶数长度返回上中点前一个

5）面试时链表解题方法论：
- 对于笔试，不用太在乎空间复杂度，一切为了时间复杂度
- 对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法

6）经典链表面试题
- 题目1：给定一个单链表的头结点head，请判断该链表是否是回文结构 leetcode 234. 回文链表
	方法一：使用容器（辅助结构O(N)）（笔试可以用）：使用辅助栈，将链表压入栈中，依次出栈，并逐个与链表值判断，如果均一致，则为true。
	
	方法二：不使用额外空间O(1)（面试最优解）：设头指针为head1，快慢指针找出中点，中点之后后的链表逆序得到头指针head2，比较head1和head2两个链表是否一致
	
- 题目二：leetcode 剑指 Offer II 026. 重排链表、143. 重排链表
- 题目三：给定值value，调整链表顺序，小于value的放左边，等于的放中间，大于的放右边
- 题目四：链表升序排序（可以后面再练习，课上还没涉及）  剑指 Offer II 077. 链表排序
- 题目五：leetcode  138. 复制带随机指针的链表
	方法一：使用辅助hash表
	方法二：不使用额外空间
- 题目六：leetcode 160. 相交链表
	这道题限定了两条链表都无环。拓展一下，链表可能无环也可能有环，求相交节点。课下进行练习。
- 题目七：leetcode 剑指 Offer II 022. 链表中环的入口节点
- 题目八：leetcode 237. 删除链表中的节点：注意，本题限定了待删除节点不是尾结点。如果是尾结点，换值的做法不能达到目的，是无解的。

14、二叉树
1）深刻理解递归序，见图
2）练习题：求二叉树中某个节点x的祖先节点。
	思路：二叉树的先序遍历的x之前的部分A，与二叉树后续遍历的x之后的部分B的交集，即为x的所有祖先节点。（这个性质的证明也可能作为面试题来问，证明过程略）
	
3）非递归先序、中序、后序遍历二叉树：
- 先序非递归思路：使用一个辅助栈，出栈立即打印，孩子节点先右后左压栈
- 后序非递归思路：使用两个辅助栈，栈一出栈不打印，而是入栈二，栈一出栈节点的孩子节点先左后右压栈二，最后栈二依次出栈并打印，即为后序
- 中序非递归思路：使用一个辅助栈，第一步，对于一个从指向root开始的节点cur，当不为null时，入栈，并指向左子树，直到为null，第二步，cur为null时，栈顶元素出栈并打印，此时将cur指向该元素的右孩子，并从第一步开始重复

4）二叉树序列化和反序列化
- 练习先序遍历的序列化和反序列化
- 练习层序遍历的序列化和反序列化

说明：中序遍历不存在反序列化，因为不同结构的中序可能得到相同的序列化结果，有歧义。

5）算法题：
- 题目一：设计题：leetcode 431. 将 N 叉树编码为二叉树
	思路：将多叉树节点的所有直接子节点构造成二叉树中节点的左子树，并且这些孩子节点在构造出的左子树中都位于右边界位置。
		  这样做，二叉树也可以唯一的反序列化得到原始的多叉树见图 将N叉树编码为二叉树
- 题目二：求二叉树的宽度（不包含null）、662. 二叉树最大宽度（包含null）
- 题目三：二叉搜索树的中序后继节点：面试题 04.06. 后继者
- 题目四：带有父节点指针的二叉树的中序后继节点
- 题目五：折纸条：纸条对折N次后展开，依次打印折痕，凹折痕打印“凹”，凸折痕打印“凸”。见图 “折纸条”
	思路：经过观察可发现，第一次折痕为凹，后面每次对折时，上次折痕上方和下方产生的新折痕分别为凹和凸。抽象化为二叉树，即有以下结论：
	对折N次，可看做二叉树的高度为N，且该二叉树有以下规律：
	i.二叉树根节点为“凹“
	ii.二叉树所有左子树的头结点为”凹“
	iii.二叉树所有右子树的头结点为”凸“
	iv.二叉树的中序遍历即为纸条展开后折痕的顺序
	因此，递归中序，打印虚拟二叉树即可得到结果
- 题目六：判断二叉树是否完全二叉树
	思路一：层序遍历时，若遇到某个节点左孩子不存在，但右孩子存在，则直接false；若某个节点左孩子和右孩子任意一个不存在，则后续遍历的节点都应该为叶子结点，否则false。
		  若遍历到最后仍未返回false，则是完全二叉树。
	思路二：递归判断：// todo
- 题目七：判断是否平衡二叉树
	思路：递归判断，对于任意一个非空节点，他必须满足以下条件
		1）他的左子树是平衡二叉树  2）他的右子树是平衡二叉树  3）他的左子树高度减右子树高度绝对值小于等于1
- 题目八：判断是否搜索二叉树
	思路：递归判断，对于任意一个非空节点，他必须满足以下条件
		1）他的左子树是搜索二叉树  2）他的右子树是搜索二叉树  3）他的值大于他左子树的最大值  4）他的值小于他右子树的最小值
- 题目九：给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离
	思路：递归判断，对于任意一个节点x，要求得出以下信息：
		1）左子树的最大距离（不经过x本身），记作A  2）右子树的最大距离（不经过x本身），记作B  3）左子树的高度，记作C   4）右子树的高度，记作D
		则有，对于任意子树x而言，他的最大距离=Max(A,B,(C+D+1)).
- 题目十：判断一棵树是否是满二叉树
	思路：满二叉树的节点数 = 2^h - 1   ，其中，h是二叉树高度
	递归判断：任意一个节点对应的子树是否满足节点数=2^h - 1  ，其中，h是当前子树的高度
- 题目十一：给定一棵二叉树root，返回他的最大搜索二叉树子树（也可以是它本身）的size，size指节点数
	思路：递归判断，任意一个节点X，收集四个信息（以x为根节点的子树的最大搜索二叉树的size（bstSize）；以x为根节点的整个子树的size（allSize），以x为根节点的子树的最大值max，以x为根节点的子树的最小值min），则收集过程x分两个大情况：
			
			1.x是它作为根节点的树的最大搜索树二叉树的节点（左子树是BST，右子树是BST，且x.val>left.max&&x.val<right.min）
			
			2.x不是它作为根节点的树的最大搜索树二叉树的节点
			
			对于情况1：bstSize = leftSize + rightSize +1 ; allSize = leftAllSize + rightAllSize +1 ; max = Math.max(x.val,rightMax) ; min = Math.min(x.val,leftMin)
			
			对于情况2：bstSize = Math.max(leftSize,rightSize) ; allSize = leftAllSize + rightAllSize +1 ; max = Math.max(x.val,rightMax) ; min = Math.min(x.val,leftMin)
			
	代码记得练习。。。

- 总结：二叉树的递归套路
	可以解决面试中绝大多数的二叉树问题尤其是树形dp问题；本质是利用递归遍历二叉树的便利性
	
	1）假设以X节点为头，假设可以向X左树和X右树要任何信息
	
	2） 在上一步的假设下，讨论以X为头节点的树，得到答案的可能性（最重要）
	
	3） 列出所有可能性后，确定到底需要向左树和右树要什么样的信息
	
	4）把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S
	
	5）递归函数都返回S，每一棵子树都这么要求
	
	6）写代码时，考虑如何把左树的信息和右树的信息整合出整棵树的信息。